# controller クラス

このクラスを継承したクラスを作ることで，様々なコントローラを作成することができる．

レトロフィットコントローラ，グローバルコントローラ共通で使用される．

※ 分散制御系であることに限定されないため，参照して良い信号と参照してはならない信号は子クラスで陽に書く必要がある

※ 他のコントローラの状態は参照できない．コントローラ同士の通信が必要な場合は，それらを1つのコントローラとして実装する必要がある


## 抽象変数

- **idx**: 出力する入力信号が印加されるバスの番号


## 抽象メソッド

- **[dx, u] = get_dx_u(x, X, V, U_global)**
  - **入力**
    - x: 自分の状態（ベクトル）
    - X: 各バスに接続された機器の状態（セル配列）
    - V: 各バスの電圧（セル配列）
    - U_global: 各バスにグローバルコントローラによって印加される入力信号（セル配列）
  - **出力**
    - dx: 自分の状態の微分（ベクトル）
    - u: 入力信号（ベクトル）  
- **nx = get_nx()**  
  状態変数の次元nxを返す



## メソッド（オーバーライド推奨）

- **[dx, u] = get_dx_u_linear(x, X, V, U_global)**  
  get_dx_uの線形版．power_networkのsimulate_linearで用いられる．  
  ※オーバーライドせずにpower_networkのsimulate_linearを使うとエラーが出る  
- **out = get_signals(X, V, U)**  
  power_networkのsimulateの終了後に，結果の信号（例えば相互作用信号v, wなど）を生成する．  
  - **入力**
    - X: 各バスに接続された機器の状態の時系列（行列のセル配列）
    - V: 各バスの時系列（行列のセル配列）
    - U: 各バスに接続された機器の状態の時系列（行列のセル配列）

  - **出力**
    - out: 構造体

- **[A, BeX, BeV, BU, C, DeX, DeV, DU] = get_linear_matrix()**  
  power_networkのget_sys(true)の場合に呼び出される．  
  オーバーライドしないでget_sys(true)をするとエラーになる．  
  `dx = A*x + BeX*(X-Xss)+BeV*(V-Vss)+BU*U`  
  `u=C*x+DeX*(X-Xss)+DeV*(V-Vss)+DU*U`  
  となるような行列を返す
  - X: ネットワークのすべてのバスの状態をスタックしたベクトル
  - V:すべてのバスの電圧をスタックしたベクトル
  - U:グローバルコントローラが生成するすべてのバスへの入力信号をスタックしたベクトル
  - Xss: 平衡状態におけるX
  - Vss: 平衡状態におけるV

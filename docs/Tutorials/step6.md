#  Step6（コントローラの自作）

- 対象者：既存の種類以外の制御器を使いたい技術者
- できるようになること：
    - 制御器の自作

## 実装しなければならないこと

- controllerクラスの継承
  - もしくは，controllerクラスの派生クラスの継承
- idxプロパティに値を入れる
  - `idx`はコントローラが出力する入力信号が印加されるバスの番号（抽象変数）
- controllerクラスの抽象メソッド2つを実装

### 抽象メソッドについて

- [dx, u] = get_dx_u(x, X, V, U_global)  
    状態の微分と入力を取得するためのメソッド
    - 入力引数
        - `x`：自分の状態
        - `X`：各バスに接続された機器の状態（セル配列）
        - `V`：各バスの電圧（セル配列）
        - `U_global`：  
            グローバルコントローラによって各バスに印加される入力信号（セル配列）  
            `add_controller_grobal`で追加されるコントローラ（グローバルコントローラ）では空配列．
    - 出力引数
        - `dx`：自分の状態の微分（ベクトル）
        - `u`：入力信号（ベクトル）

- `nx = get_nx()`
    状態変数の次元を取得するためのメソッド
    - 出力引数`nx`：状態変数の次元

### 注意するべき点

- 必要な物理量は自前で計算する必要あり
- controllerクラスはグローバルコントローラ・レトロフィットコントローラ・その他コントローラに対して共通で継承される
  - controllerクラスを継承するだけでは分散制御系であることを前提にしていないため，分散制御器を作成する場合は，参照して良い信号と参照してはならない信号を派生クラスにて陽に書く必要がある
- 他のコントローラの状態を参照することはできない
  - コントローラ同士の通信が必要な場合は，それらを一つのコントローラとして実装する必要がある


## 実装した方が望ましいこと

- 線形化関連のメソッドのオーバライド

## 線形化関連のメソッドについて

- `[A, BeX, BeV, Bu, C, DeX, DeV, Du] = get_linear_matrix(obj)`  
    線形化したコントローラを取得するためのメソッドで
    $$
    \dot{x}=Ax+B_X (X-X*)+B_V (V-V*)+B_u U_{global}\\
    u=Cx+D_X (X-X*)+D_V (V-V*)+D_u U_{global}
    $$  
    を満たす行列を返す

- `[dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global)`  
    線形化したコントローラの状態変数の微分と入力を取得するための関数
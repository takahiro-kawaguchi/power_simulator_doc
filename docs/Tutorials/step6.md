# 【第六回】コントローラの自作

- 本ステップでできるようになること  
    自分で用意したコントローラをpower_simulatorに実装できるようになる

## 実装しなければならないこと

- controllerクラスの継承
    - もしくは，既存のcontrollerクラスの派生クラスの継承
- `idx_input`と`idx_observe`のそれぞれに値を入れる
    - `idx_input`：コントローラの出力信号，システムへの入力信号が印加されるバスの番号（抽象変数）
    - `idx_observe`：コントローラが観測できるバスの番号（抽象変数）
- controllerクラスの抽象メソッド2つを実装
    - 具体的には `get_dx_u`, `get_nx`（下で詳細を説明）

### 抽象メソッドについて

- `[dx, u] = get_dx_u(obj, x, X, V, I, U_global)`  
    コントローラの状態の微分と出力信号（システムへの入力信号）を取得するためのメソッド
    - 入力引数
        - `x`：コントローラのの状態（ベクトル）
        - `X`：各バスに接続された機器の状態（セル配列）
        - `V`：各バスの電圧（2*bus数 の行列）
        - `I`：各バスの電流（2*bus数 の行列）
        - `U_global`：  
            グローバルコントローラによって各バスに印加される入力信号（セル配列）  
            `add_controller_grobal`で追加されるコントローラ（グローバルコントローラ）では空配列．
    - 出力引数
        - `dx`：コントローラの状態の微分（ベクトル）
        - `u`：コントローラの出力信号，システムへの入力信号（ベクトル）

- `nx = get_nx(obj)`
    コントローラの状態変数の次元を取得するためのメソッド
    - 出力引数`nx`：コントローラの状態変数の次元

### 注意するべき点

- 必要な物理量は自前で計算する必要あり
    - 用意されている物理量は各バスに接続された機器の状態・各バスの電圧と電流・グローバルコントローラからの入力信号のみ．
- controllerクラスはグローバルコントローラ・レトロフィットコントローラ・その他コントローラに対して共通で継承される
    - controllerクラスを継承するだけでは分散制御系であることを前提にしていないため，分散制御器を作成する場合は，参照して良い信号と参照してはならない信号を派生クラスにて陽に書く必要がある
- 他のコントローラの状態を参照することはできない
    - コントローラ同士の通信が必要な場合は，それらを一つのコントローラとして実装する必要がある


## 実装した方が望ましいこと

- 線形化関連のメソッドのオーバライド

### 線形化関連のメソッドについて

- `[A, BeX, BeV, Bu, C, DeX, DeV, Du] = get_linear_matrix(obj)`  
    線形化したコントローラを取得するためのメソッドで
    $$
    \dot{x}=Ax+B_X (X-X*)+B_V (V-V*)+B_u U_{global}\\
    u=Cx+D_X (X-X*)+D_V (V-V*)+D_u U_{global}
    $$
    を満たす行列を返す

- `[dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global)`  
    線形化したコントローラの状態変数の微分と入力を取得するための関数．  
    各変数については上の`get_dx_u`を参照のこと．